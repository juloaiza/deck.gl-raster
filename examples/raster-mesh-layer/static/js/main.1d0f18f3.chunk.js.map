{"version":3,"sources":["../../../src/webgl/texture/combine-bands.js","../../../src/webgl/spectral-indices/normalized-difference.js","../../../src/webgl/pansharpen/pansharpen-brovey.js","../../../src/webgl/color/colormap.js","../../../src/deckgl/raster-mesh-layer/matrix.js","../../../src/deckgl/images.js","../../../src/deckgl/raster-mesh-layer/raster-mesh-layer.js","../../../src/deckgl/raster-mesh-layer/raster-mesh-layer-fragment.js","util.js","terrain-tile-layer.js","App.js","serviceWorker.js","index.js"],"names":["name","fs","getUniforms","opts","imageBands","length","bitmapTexture_r","bitmapTexture_g","bitmapTexture_b","bitmapTexture_a","inject","imagePan","panWeight","bitmapTexture_pan","imageColormap","bitmapTexture_colormap","shouldComposeModelMatrix","viewport","coordinateSystem","COORDINATE_SYSTEM","CARTESIAN","METER_OFFSETS","DEFAULT","isGeospatial","DEFAULT_TEXTURE_PARAMETERS","GL","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","loadTexture","gl","imageData","Texture2D","parameters","validateGeometryAttributes","attributes","log","assert","positions","POSITION","getGeometry","data","Geometry","Error","defaultProps","SimpleMeshLayer","modules","type","value","compare","images","moduleProps","RasterMeshLayer","this","context","programManager","ProgramManager","getDefaultProgramManager","fsStr1","fsStr2","_hookFunctions","includes","addShaderHook","setState","transpileToGLSL100","isWebGL2","props","Object","assign","project32","phongLighting","picking","oldProps","changeFlags","mesh","extensionsChanged","state","model","delete","getModel","hasNormals","Boolean","NORMAL","normals","getAttributeManager","invalidateAll","updateImages","setDrawMode","wireframe","LINE_STRIP","TRIANGLES","newImages","imagesDirty","key","changedKeys","push","isEqual","Array","isArray","map","x","loadImages","uniforms","keys","values","every","item","sizeScale","_instanced","setUniforms","composeModelMatrix","flatShading","updateModuleSettings","draw","image","Model","getShaders","id","geometry","isInstanced","layerName","colorStr","nBands","colorBands","slice","getLandsatUrl","options","bands","url","y","z","bandsArray","params","join","color_ops","searchParams","URLSearchParams","baseUrl","toString","getTerrainUrl","replace","ELEVATION_DECODER","rScaler","gScaler","bScaler","offset","getMeshMaxError","registerLoaders","ImageLoader","DUMMY_DATA","getTileData","a","landsatBands","usePan","combineBands","normalizedDifference","terrainUrl","terrain","loadTerrain","terrainImage","bounds","elevationDecoder","meshMaxError","bandsUrls","band","loadImage","panUrl","pansharpenBrovey","colormap","Promise","all","renderSubLayers","tile","getPolygonOffset","modelMatrix","getModelMatrix","getPosition","d","getColor","worldScale","Math","pow","xScale","yScale","xOffset","yOffset","Matrix4","translate","scale","workerUrl","load","TerrainLoader","format","height","RGB","LUMINANCE","INITIAL_VIEW_STATE","latitude","longitude","zoom","bearing","pitch","maxPitch","App","layers","minZoom","maxZoom","TileLayer","tileSize","maxRequests","TerrainTileLayer","initialViewState","controller","React","Component","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.1d0f18f3.chunk.js","sourcesContent":["function getUniforms(opts = {}) {\n  const { imageBands } = opts;\n  if (!imageBands || imageBands.length === 0) {\n    return;\n  }\n\n  const [\n    bitmapTexture_r,\n    bitmapTexture_g,\n    bitmapTexture_b,\n    bitmapTexture_a,\n  ] = imageBands;\n\n  return {\n    bitmapTexture_r,\n    bitmapTexture_g,\n    bitmapTexture_b,\n    bitmapTexture_a,\n  };\n}\n\nconst fs = `\\\nuniform sampler2D bitmapTexture_r;\nuniform sampler2D bitmapTexture_g;\nuniform sampler2D bitmapTexture_b;\nuniform sampler2D bitmapTexture_a;\n`;\n\nexport default {\n  name: \"combine-bands\",\n  fs,\n  getUniforms,\n  inject: {\n    \"fs:DECKGL_CREATE_COLOR\": `\n    float r_band = texture2D(bitmapTexture_r, coord).r;\n    float g_band = texture2D(bitmapTexture_g, coord).r;\n    float b_band = texture2D(bitmapTexture_b, coord).r;\n    float a_band = texture2D(bitmapTexture_a, coord).r;\n\n    image = vec4(r_band, g_band, b_band, a_band);\n    `,\n  },\n};\n","const fs = `\\\n// Calculate standard normalized difference\nfloat normalized_difference_calc(vec4 image) {\n  return ((image.r - image.g) / (image.r + image.g));\n}\n`;\n\nexport default {\n  name: \"normalized_difference\",\n  fs,\n  inject: {\n    \"fs:DECKGL_MUTATE_COLOR\": `\n    image = vec4(normalized_difference_calc(image), 0., 0., 0.);\n    `,\n  },\n};\n","function getUniforms(opts = {}) {\n  const { imagePan, panWeight = 0.2 } = opts;\n  \n  if (!imagePan) {\n    return;\n  }\n  \n  return {\n    bitmapTexture_pan: imagePan,\n    panWeight,\n  };\n}\n\nconst fs = `\\\nuniform sampler2D bitmapTexture_pan;\nuniform float panWeight;\n\n// calculate pansharpen ratio\nfloat pansharpen_brovey_ratio(vec4 rgb, float pan, float weight) {\n    return pan / ((rgb.r + rgb.g + rgb.b * weight) / (2. + weight));\n}\n\n// Brovey Method: Each resampled, multispectral pixel is\n// multiplied by the ratio of the corresponding\n// panchromatic pixel intensity to the sum of all the\n// multispectral intensities.\n// Original code from https://github.com/mapbox/rio-pansharpen\nvec4 pansharpen_brovey_calc(vec4 rgb, float pan, float weight) {\n    float ratio = pansharpen_brovey_ratio(rgb, pan, weight);\n    vec4 alteredRGB = ratio * rgb;\n    return clamp(alteredRGB, 0., 1.);\n}\n`;\n\nexport default {\n  name: \"pansharpen_brovey\",\n  fs,\n  getUniforms,\n  inject: {\n    \"fs:DECKGL_MUTATE_COLOR\": `\n    float pan_band = texture2D(bitmapTexture_pan, coord).r;\n    image = pansharpen_brovey_calc(image, pan_band, panWeight);\n    `,\n  },\n};\n","function getUniforms(opts = {}) {\n  const { imageColormap } = opts;\n\n  if (!imageColormap) {\n    return;\n  }\n\n  return {\n    bitmapTexture_colormap: imageColormap,\n  };\n}\n\nconst fs = `\\\nuniform sampler2D bitmapTexture_colormap;\n\n// Apply colormap texture given value\n// Since the texture only varies in the x direction, setting v to 0.5 as a\n// constant is fine\n// Assumes the input range of value is -1 to 1\nvec4 colormap_apply(sampler2D colormap, vec4 image) {\n  vec2 uv = vec2(0.5 * image.r + 0.5, 0.5);\n  return texture2D(colormap, uv);\n}\n`;\n\nexport default {\n  name: \"colormap\",\n  fs,\n  getUniforms,\n  inject: {\n    \"fs:DECKGL_MUTATE_COLOR\": `\n    image = colormap_apply(bitmapTexture_colormap, image);\n    `,\n  },\n};\n","import { COORDINATE_SYSTEM } from \"@deck.gl/core\";\n\n\n// only apply composeModelMatrix when in cartesian or meter_offsets coordinate system\n// with `composeModelMatrix` enabled, the rotation part of the layer's modelMatrix will be composed to instance's transformations\n// since rotating latitude and longitude can not provide meaningful results, hence `composeModelMatrix` is disabled\n// when in LNGLAT and LNGLAT_OFFSET coordinates.\nexport function shouldComposeModelMatrix(viewport, coordinateSystem) {\n  return (\n    coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ||\n    coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS ||\n    (coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial)\n  );\n}\n","import { Texture2D } from \"@luma.gl/core\";\nimport GL from \"@luma.gl/constants\";\nimport isEqual from \"lodash.isequal\";\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE,\n};\n\nexport function loadImages({ gl, images, props, oldProps }) {\n  // Change to `true` if we need to setState with a new `images` object\n  let imagesDirty = false;\n\n  // If there are any removed keys, which previously existed in oldProps and\n  // this.state.images but no longer exist in props, remove from the images\n  // object\n  if (oldProps && oldProps.images) {\n    for (const key in oldProps.images) {\n      if (props.images && !(key in props.images) && key in images) {\n        delete images[key];\n        imagesDirty = true;\n      }\n    }\n  }\n\n  // Check if any keys of props.images have changed\n  const changedKeys = [];\n  for (const key in props.images) {\n    // If oldProps.images didn't exist or it existed and this key didn't exist\n    if (!oldProps.images || (oldProps.images && !(key in oldProps.images))) {\n      changedKeys.push(key);\n      continue;\n    }\n\n    // Deep compare when the key previously existed to see if it changed\n    if (!isEqual(props.images[key], oldProps.images[key])) {\n      changedKeys.push(key);\n    }\n  }\n\n  for (const key of changedKeys) {\n    const imageData = props.images[key];\n    if (!imageData) {\n      continue;\n    }\n\n    if (Array.isArray(imageData)) {\n      images[key] = imageData.map((x) => loadTexture(gl, x));\n    } else {\n      images[key] = loadTexture(gl, imageData);\n    }\n    imagesDirty = true;\n  }\n\n  if (imagesDirty) {\n    return images;\n  }\n\n  return null;\n}\n\nfunction loadTexture(gl, imageData) {\n  if (imageData instanceof Texture2D) {\n    return imageData;\n  } else if (imageData) {\n    return new Texture2D(gl, {\n      parameters: DEFAULT_TEXTURE_PARAMETERS,\n      ...imageData,\n    });\n  }\n}\n","import GL from \"@luma.gl/constants\";\nimport { SimpleMeshLayer } from \"@deck.gl/mesh-layers\";\nimport { Model, Geometry, isWebGL2 } from \"@luma.gl/core\";\nimport { project32, phongLighting, picking, log } from \"@deck.gl/core\";\nimport { ProgramManager } from \"@luma.gl/engine\";\n\nimport { shouldComposeModelMatrix } from \"./matrix\";\nimport { loadImages } from \"../images\";\nimport fs from \"./raster-mesh-layer-fragment\";\n\nfunction validateGeometryAttributes(attributes) {\n  log.assert(\n    attributes.positions || attributes.POSITION,\n    'RasterMeshLayer requires \"postions\" or \"POSITION\" attribute in mesh property.'\n  );\n}\n\n/*\n * Convert mesh data into geometry\n * @returns {Geometry} geometry\n */\nfunction getGeometry(data) {\n  if (data.attributes) {\n    validateGeometryAttributes(data.attributes);\n    if (data instanceof Geometry) {\n      return data;\n    } else {\n      return new Geometry(data);\n    }\n  } else if (data.positions || data.POSITION) {\n    validateGeometryAttributes(data);\n    return new Geometry({\n      attributes: data,\n    });\n  }\n  throw Error(\"Invalid mesh\");\n}\n\nconst defaultProps = {\n  ...SimpleMeshLayer.defaultProps,\n  modules: { type: \"array\", value: [], compare: true },\n  images: { type: \"object\", value: {}, compare: true },\n  moduleProps: { type: \"object\", value: {}, compare: true },\n};\n\nexport default class RasterMeshLayer extends SimpleMeshLayer {\n  initializeState() {\n    const { gl } = this.context;\n    const programManager = ProgramManager.getDefaultProgramManager(gl);\n\n    const fsStr1 = \"fs:DECKGL_MUTATE_COLOR(inout vec4 image, in vec2 coord)\";\n    const fsStr2 = \"fs:DECKGL_CREATE_COLOR(inout vec4 image, in vec2 coord)\";\n\n    // Only initialize shader hook functions _once globally_\n    // Since the program manager is shared across all layers, but many layers\n    // might be created, this solves the performance issue of always adding new\n    // hook functions. See #22\n    if (!programManager._hookFunctions.includes(fsStr1)) {\n      programManager.addShaderHook(fsStr1);\n    }\n    if (!programManager._hookFunctions.includes(fsStr2)) {\n      programManager.addShaderHook(fsStr2);\n    }\n\n    // images is a mapping from keys to Texture2D objects. The keys should match\n    // names of uniforms in shader modules\n    this.setState({ images: {} });\n\n    super.initializeState();\n  }\n\n  getShaders() {\n    const transpileToGLSL100 = !isWebGL2(this.context.gl);\n    const { modules = [] } = this.props;\n\n    // use object.assign to make sure we don't overwrite existing fields like `vs`, `modules`...\n    return Object.assign({}, super.getShaders(), {\n      fs,\n      transpileToGLSL100,\n      modules: [project32, phongLighting, picking, ...modules],\n    });\n  }\n\n  updateState({ props, oldProps, changeFlags }) {\n    super.updateState({ props, oldProps, changeFlags });\n\n    if (\n      props.mesh !== oldProps.mesh ||\n      changeFlags.extensionsChanged ||\n      props.modules !== oldProps.modules\n    ) {\n      if (this.state.model) {\n        this.state.model.delete();\n      }\n      if (props.mesh) {\n        this.setState({ model: this.getModel(props.mesh) });\n\n        const attributes = props.mesh.attributes || props.mesh;\n        this.setState({\n          hasNormals: Boolean(attributes.NORMAL || attributes.normals),\n        });\n      }\n      this.getAttributeManager().invalidateAll();\n    }\n\n    if (props && props.images) {\n      this.updateImages({ props, oldProps });\n    }\n\n    if (this.state.model) {\n      this.state.model.setDrawMode(\n        this.props.wireframe ? GL.LINE_STRIP : GL.TRIANGLES\n      );\n    }\n  }\n\n  updateImages({ props, oldProps }) {\n    const { images } = this.state;\n    const { gl } = this.context;\n\n    const newImages = loadImages({\n      gl,\n      images,\n      props,\n      oldProps,\n    });\n\n    if (newImages) {\n      this.setState({ images: newImages });\n    }\n  }\n\n  draw({ uniforms }) {\n    const { model, images } = this.state;\n    const { moduleProps } = this.props;\n\n    // Render the image\n    if (\n      !model ||\n      !images ||\n      Object.keys(images).length === 0 ||\n      !Object.values(images).every((item) => item)\n    ) {\n      return;\n    }\n\n    const { viewport } = this.context;\n    const { sizeScale, coordinateSystem, _instanced } = this.props;\n\n    model\n      .setUniforms(\n        Object.assign({}, uniforms, {\n          sizeScale,\n          composeModelMatrix:\n            !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),\n          flatShading: !this.state.hasNormals,\n        })\n      )\n      .updateModuleSettings({\n        ...moduleProps,\n        ...images,\n      })\n      .draw();\n  }\n\n  finalizeState() {\n    super.finalizeState();\n\n    if (this.state.images) {\n      for (const image of Object.values(this.state.images)) {\n        if (Array.isArray(image)) {\n          image.map((x) => x.delete());\n        } else {\n          image.delete();\n        }\n      }\n    }\n  }\n\n  getModel(mesh) {\n    const { gl } = this.context;\n\n    const model = new Model(\n      gl,\n      Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: getGeometry(mesh),\n        isInstanced: true,\n      })\n    );\n\n    return model;\n  }\n}\n\nRasterMeshLayer.layerName = \"RasterMeshLayer\";\nRasterMeshLayer.defaultProps = defaultProps;\n","export default `#version 300 es\n#define SHADER_NAME raster-mesh-layer-fs\n\nprecision highp float;\n\nuniform bool hasTexture;\n\nuniform bool flatShading;\nuniform float opacity;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  geometry.uv = vTexCoord;\n  vec4 image;\n  DECKGL_CREATE_COLOR(image, vTexCoord);\n\n  DECKGL_MUTATE_COLOR(image, vTexCoord);\n\n  vec3 normal;\n  if (flatShading) {\n\n// NOTE(Tarek): This is necessary because\n// headless.gl reports the extension as\n// available but does not support it in\n// the shader.\n#ifdef DERIVATIVES_AVAILABLE\n    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n  } else {\n    normal = normals_commonspace;\n  }\n\n  vec3 lightColor = lighting_getLightColor(image.rgb, cameraPosition, position_commonspace.xyz, normal);\n  fragColor = vec4(lightColor, opacity);\n\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n","export const TERRAIN_IMAGE = `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png`;\nexport const MOSAIC_URL =\n  \"s3://kylebarron-landsat-test/mosaics/8113f57876010a63aadacef4eac6d010d10c9aafcf36a5ece064ea7f.json.gz\";\n\nfunction colorStr(nBands) {\n  const colorBands = \"RGB\".slice(0, nBands);\n  let colorStr = `gamma ${colorBands} 3.5, sigmoidal ${colorBands} 15 0.35`;\n\n  if (nBands === 3) {\n    colorStr += \", saturation 1.7\";\n  }\n  return colorStr;\n}\n\nexport function getLandsatUrl(options) {\n  const { bands, url, x, y, z } = options;\n  const bandsArray = Array.isArray(bands) ? bands : [bands];\n  const params = {\n    url,\n    bands: bandsArray.join(\",\"),\n    color_ops: colorStr(bandsArray.length),\n  };\n  const searchParams = new URLSearchParams(params);\n  let baseUrl = `https://us-west-2-lambda.kylebarron.dev/landsat/tiles/${z}/${x}/${y}.jpg?`;\n  baseUrl += searchParams.toString();\n  return baseUrl;\n}\n\nexport function getTerrainUrl({ x, y, z }) {\n  return TERRAIN_IMAGE.replace(\"{x}\", x).replace(\"{y}\", y).replace(\"{z}\", z);\n}\n\nexport const ELEVATION_DECODER = {\n  rScaler: 256,\n  gScaler: 1,\n  bScaler: 1 / 256,\n  offset: -32768,\n};\n\n// Error suggestion from here\n// https://www.linkedin.com/pulse/fast-cesium-terrain-rendering-new-quantized-mesh-output-alvaro-huarte/\nexport function getMeshMaxError(z) {\n  return 77067.34 / (1 << z)\n}\n","import GL from \"@luma.gl/constants\";\nimport { COORDINATE_SYSTEM } from \"@deck.gl/core\";\nimport { load, registerLoaders } from \"@loaders.gl/core\";\nimport { TerrainLoader } from \"@loaders.gl/terrain\";\nimport { ImageLoader } from \"@loaders.gl/images\";\nimport { TileLayer } from \"@deck.gl/geo-layers\";\nimport { Matrix4 } from \"math.gl\";\nimport {\n  RasterMeshLayer,\n  combineBands,\n  pansharpenBrovey,\n  normalizedDifference,\n  colormap,\n} from \"@kylebarron/deck.gl-raster\";\n\nimport {\n  ELEVATION_DECODER,\n  getLandsatUrl,\n  getTerrainUrl,\n  getMeshMaxError,\n} from \"./util\";\n\nregisterLoaders([ImageLoader]);\n\nconst DUMMY_DATA = [1];\n\nconst MOSAIC_URL = \"dynamodb://us-west-2/landsat8-2019-spring\";\n\nexport function TerrainTileLayer({ minZoom = 0, maxZoom = 17 } = {}) {\n  return new TileLayer({\n    id: \"terrain-tiles\",\n    minZoom,\n    maxZoom,\n    tileSize: 256,\n    maxRequests: 12,\n    getTileData,\n    renderSubLayers,\n  });\n}\n\nasync function getTileData({ x, y, z }) {\n  // BAND CONFIGURATION\n  // In a real application the following would come from props\n  const landsatBands = [5, 4];\n  const usePan =\n    z >= 12 &&\n    landsatBands[0] === 4 &&\n    landsatBands[1] === 3 &&\n    landsatBands[2] === 2;\n  const useColormap = true;\n  const colormapUrl =\n    \"https://cdn.jsdelivr.net/gh/kylebarron/deck.gl-raster/assets/colormaps/spectral.png\";\n  const modules = [combineBands, normalizedDifference];\n\n  // Load terrain\n  const terrainUrl = getTerrainUrl({ x, y, z });\n  const bounds = [0, 1, 1, 0];\n  const terrain = loadTerrain({\n    terrainImage: terrainUrl,\n    bounds,\n    elevationDecoder: ELEVATION_DECODER,\n    meshMaxError: getMeshMaxError(z),\n  });\n\n  const bandsUrls = landsatBands.map((band) =>\n    getLandsatUrl({ x, y, z, bands: band, url: MOSAIC_URL })\n  );\n  const imageBands = bandsUrls.map((url) => loadImage(url));\n\n  let imagePan;\n  if (usePan) {\n    const panUrl = getLandsatUrl({ x, y, z, bands: 8, url: MOSAIC_URL });\n    imagePan = loadImage(panUrl);\n    modules.push(pansharpenBrovey);\n  }\n\n  // Load colormap\n  // Only load if landsatBandCombination is not RGB\n  let imageColormap;\n  if (useColormap) {\n    imageColormap = loadImage(colormapUrl);\n    modules.push(colormap);\n  }\n\n  // Await all images together\n  await Promise.all([imagePan, imageBands, imageColormap]);\n\n  const images = {\n    imageBands: await Promise.all(imageBands),\n    imageColormap: await imageColormap,\n    imagePan: await imagePan,\n  };\n\n  return {\n    images,\n    modules,\n    terrain: await terrain,\n  };\n}\n\nfunction renderSubLayers(props) {\n  const { data, tile } = props;\n\n  if (!data) {\n    return null;\n  }\n\n  const { images, modules, terrain } = data;\n\n  return [\n    new RasterMeshLayer(props, {\n      data: DUMMY_DATA,\n      mesh: terrain,\n      modules,\n      images,\n      getPolygonOffset: null,\n      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n      modelMatrix: getModelMatrix(tile),\n      getPosition: (d) => [0, 0, 0],\n      // Color to use if surfaceImage is unavailable\n      getColor: [255, 255, 255],\n    }),\n  ];\n}\n\n// From https://github.com/uber/deck.gl/blob/b1901b11cbdcb82b317e1579ff236d1ca1d03ea7/modules/geo-layers/src/mvt-tile-layer/mvt-tile-layer.js#L41-L52\nfunction getModelMatrix(tile) {\n  const WORLD_SIZE = 512;\n  const worldScale = Math.pow(2, tile.z);\n\n  const xScale = WORLD_SIZE / worldScale;\n  const yScale = -xScale;\n\n  const xOffset = (WORLD_SIZE * tile.x) / worldScale;\n  const yOffset = WORLD_SIZE * (1 - tile.y / worldScale);\n\n  return new Matrix4()\n    .translate([xOffset, yOffset, 0])\n    .scale([xScale, yScale, 1]);\n}\n\nfunction loadTerrain({\n  terrainImage,\n  bounds,\n  elevationDecoder,\n  meshMaxError,\n  workerUrl,\n}) {\n  if (!terrainImage) {\n    return null;\n  }\n  const options = {\n    terrain: {\n      bounds,\n      meshMaxError,\n      elevationDecoder,\n    },\n  };\n  if (workerUrl) {\n    options.terrain.workerUrl = workerUrl;\n  }\n  return load(terrainImage, TerrainLoader, options);\n}\n\nexport async function loadImage(url) {\n  const image = await load(url, ImageLoader);\n  return {\n    data: image,\n    format: image && image.height === 10 ? GL.RGB : GL.LUMINANCE,\n  };\n}\n","import React from \"react\";\nimport DeckGL from \"@deck.gl/react\";\nimport { TerrainTileLayer } from \"./terrain-tile-layer\";\n\nconst INITIAL_VIEW_STATE = {\n  latitude: 46.21,\n  longitude: -122.18,\n  zoom: 11.5,\n  bearing: 140,\n  pitch: 60,\n  maxPitch: 80,\n};\n\nexport default class App extends React.Component {\n  render() {\n    const layers = TerrainTileLayer({ minZoom: 7, maxZoom: 12 });\n\n    return (\n      <DeckGL\n        initialViewState={INITIAL_VIEW_STATE}\n        controller={true}\n        layers={layers}\n      />\n    );\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}