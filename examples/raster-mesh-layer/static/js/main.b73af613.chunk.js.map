{"version":3,"sources":["../../../src/webgl/texture/combine-bands.js","../../../src/webgl/spectral-indices/normalized-difference.js","../../../src/webgl/pansharpen/pansharpen-brovey.js","../../../src/webgl/color/colormap.js","../../../src/deckgl/raster-mesh-layer/matrix.js","../../../src/deckgl/images.js","../../../src/deckgl/raster-mesh-layer/raster-mesh-layer.js","../../../src/deckgl/raster-mesh-layer/raster-mesh-layer-fragment.js","util.js","terrain-tile-layer.js","App.js","serviceWorker.js","index.js"],"names":["name","fs","getUniforms","opts","imageBands","length","bitmapTexture_r","bitmapTexture_g","bitmapTexture_b","bitmapTexture_a","inject","imagePan","panWeight","bitmapTexture_pan","imageColormap","bitmapTexture_colormap","shouldComposeModelMatrix","viewport","coordinateSystem","COORDINATE_SYSTEM","CARTESIAN","METER_OFFSETS","DEFAULT","isGeospatial","DEFAULT_TEXTURE_PARAMETERS","GL","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","loadTexture","gl","imageData","Texture2D","parameters","validateGeometryAttributes","attributes","log","assert","positions","POSITION","getGeometry","data","Geometry","Error","defaultProps","SimpleMeshLayer","modules","type","value","compare","images","moduleProps","RasterMeshLayer","this","context","programManager","ProgramManager","getDefaultProgramManager","fsStr1","fsStr2","_hookFunctions","includes","addShaderHook","setState","transpileToGLSL100","isWebGL2","props","Object","assign","project32","phongLighting","picking","oldProps","changeFlags","mesh","extensionsChanged","state","model","delete","getModel","hasNormals","Boolean","NORMAL","normals","getAttributeManager","invalidateAll","updateImages","setDrawMode","wireframe","LINE_STRIP","TRIANGLES","newImages","imagesDirty","key","changedKeys","push","isEqual","Array","isArray","map","x","loadImages","uniforms","keys","values","every","item","sizeScale","_instanced","setUniforms","composeModelMatrix","flatShading","updateModuleSettings","draw","image","Model","getShaders","id","geometry","isInstanced","layerName","colorStr","nBands","colorBands","slice","getLandsatUrl","options","bands","url","y","z","bandsArray","params","join","color_ops","searchParams","URLSearchParams","baseUrl","toString","getTerrainUrl","replace","ELEVATION_DECODER","rScaler","gScaler","bScaler","offset","getMeshMaxError","registerLoaders","ImageLoader","DUMMY_DATA","getTileData","a","landsatBands","usePan","combineBands","normalizedDifference","terrainUrl","terrain","loadTerrain","terrainImage","bounds","elevationDecoder","meshMaxError","bandsUrls","band","loadImage","panUrl","pansharpenBrovey","colormap","Promise","all","renderSubLayers","tile","getPolygonOffset","modelMatrix","getModelMatrix","getPosition","d","getColor","worldScale","Math","pow","xScale","yScale","xOffset","yOffset","Matrix4","translate","scale","workerUrl","load","TerrainLoader","format","height","RGB","LUMINANCE","INITIAL_VIEW_STATE","latitude","longitude","zoom","bearing","pitch","minZoom","maxPitch","App","layers","maxZoom","TileLayer","tileSize","maxRequests","TerrainTileLayer","initialViewState","controller","glOptions","powerPreference","React","Component","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.b73af613.chunk.js","sourcesContent":["function getUniforms(opts = {}) {\n  const {imageBands} = opts;\n  if (!imageBands || imageBands.length === 0) {\n    return;\n  }\n\n  const [\n    bitmapTexture_r,\n    bitmapTexture_g,\n    bitmapTexture_b,\n    bitmapTexture_a,\n  ] = imageBands;\n\n  return {\n    bitmapTexture_r,\n    bitmapTexture_g,\n    bitmapTexture_b,\n    bitmapTexture_a,\n  };\n}\n\nconst fs = `\\\nuniform sampler2D bitmapTexture_r;\nuniform sampler2D bitmapTexture_g;\nuniform sampler2D bitmapTexture_b;\nuniform sampler2D bitmapTexture_a;\n`;\n\nexport default {\n  name: 'combine-bands',\n  fs,\n  getUniforms,\n  inject: {\n    'fs:DECKGL_CREATE_COLOR': `\n    float r_band = texture2D(bitmapTexture_r, coord).r;\n    float g_band = texture2D(bitmapTexture_g, coord).r;\n    float b_band = texture2D(bitmapTexture_b, coord).r;\n    float a_band = texture2D(bitmapTexture_a, coord).r;\n\n    image = vec4(r_band, g_band, b_band, a_band);\n    `,\n  },\n};\n","// Calculate standard normalized difference\nconst fs = `\\\nfloat normalized_difference_calc(vec4 image) {\n  return ((image.r - image.g) / (image.r + image.g));\n}\n`;\n\nexport default {\n  name: 'normalized_difference',\n  fs,\n  inject: {\n    'fs:DECKGL_MUTATE_COLOR': `\n    image = vec4(normalized_difference_calc(image), 0., 0., 0.);\n    `,\n  },\n};\n","function getUniforms(opts = {}) {\n  const {imagePan, panWeight = 0.2} = opts;\n\n  if (!imagePan) {\n    return;\n  }\n\n  return {\n    bitmapTexture_pan: imagePan,\n    panWeight,\n  };\n}\n\n// Brovey Method: Each resampled, multispectral pixel is\n// multiplied by the ratio of the corresponding\n// panchromatic pixel intensity to the sum of all the\n// multispectral intensities.\n// Original code from https://github.com/mapbox/rio-pansharpen\nconst fs = `\\\nuniform sampler2D bitmapTexture_pan;\nuniform float panWeight;\n\nfloat pansharpen_brovey_ratio(vec4 rgb, float pan, float weight) {\n    return pan / ((rgb.r + rgb.g + rgb.b * weight) / (2. + weight));\n}\n\nvec4 pansharpen_brovey_calc(vec4 rgb, float pan, float weight) {\n    float ratio = pansharpen_brovey_ratio(rgb, pan, weight);\n    vec4 alteredRGB = ratio * rgb;\n    return clamp(alteredRGB, 0., 1.);\n}\n`;\n\nexport default {\n  name: 'pansharpen_brovey',\n  fs,\n  getUniforms,\n  inject: {\n    'fs:DECKGL_MUTATE_COLOR': `\n    float pan_band = texture2D(bitmapTexture_pan, coord).r;\n    image = pansharpen_brovey_calc(image, pan_band, panWeight);\n    `,\n  },\n};\n","function getUniforms(opts = {}) {\n  const {imageColormap} = opts;\n\n  if (!imageColormap) {\n    return;\n  }\n\n  return {\n    bitmapTexture_colormap: imageColormap,\n  };\n}\n\n// Apply colormap texture given value\n// Since the texture only varies in the x direction, setting v to 0.5 as a\n// constant is fine\n// Assumes the input range of value is -1 to 1\nconst fs = `\\\nuniform sampler2D bitmapTexture_colormap;\n\nvec4 colormap_apply(sampler2D colormap, vec4 image) {\n  vec2 uv = vec2(0.5 * image.r + 0.5, 0.5);\n  return texture2D(colormap, uv);\n}\n`;\n\nexport default {\n  name: 'colormap',\n  fs,\n  getUniforms,\n  inject: {\n    'fs:DECKGL_MUTATE_COLOR': `\n    image = colormap_apply(bitmapTexture_colormap, image);\n    `,\n  },\n};\n","import {COORDINATE_SYSTEM} from '@deck.gl/core';\n\n// only apply composeModelMatrix when in cartesian or meter_offsets coordinate system\n// with `composeModelMatrix` enabled, the rotation part of the layer's modelMatrix will be composed to instance's transformations\n// since rotating latitude and longitude can not provide meaningful results, hence `composeModelMatrix` is disabled\n// when in LNGLAT and LNGLAT_OFFSET coordinates.\nexport function shouldComposeModelMatrix(viewport, coordinateSystem) {\n  return (\n    coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ||\n    coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS ||\n    (coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial)\n  );\n}\n","import {Texture2D} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport isEqual from 'lodash.isequal';\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE,\n};\n\nexport function loadImages({gl, images, props, oldProps}) {\n  // Change to `true` if we need to setState with a new `images` object\n  let imagesDirty = false;\n\n  // If there are any removed keys, which previously existed in oldProps and\n  // this.state.images but no longer exist in props, remove from the images\n  // object\n  if (oldProps && oldProps.images) {\n    for (const key in oldProps.images) {\n      if (props.images && !(key in props.images) && key in images) {\n        delete images[key];\n        imagesDirty = true;\n      }\n    }\n  }\n\n  // Check if any keys of props.images have changed\n  const changedKeys = [];\n  for (const key in props.images) {\n    // If oldProps.images didn't exist or it existed and this key didn't exist\n    if (!oldProps.images || (oldProps.images && !(key in oldProps.images))) {\n      changedKeys.push(key);\n      continue;\n    }\n\n    // Deep compare when the key previously existed to see if it changed\n    if (!isEqual(props.images[key], oldProps.images[key])) {\n      changedKeys.push(key);\n    }\n  }\n\n  for (const key of changedKeys) {\n    const imageData = props.images[key];\n    if (!imageData) {\n      continue;\n    }\n\n    if (Array.isArray(imageData)) {\n      images[key] = imageData.map((x) => loadTexture(gl, x));\n    } else {\n      images[key] = loadTexture(gl, imageData);\n    }\n    imagesDirty = true;\n  }\n\n  if (imagesDirty) {\n    return images;\n  }\n\n  return null;\n}\n\nfunction loadTexture(gl, imageData) {\n  if (imageData instanceof Texture2D) {\n    return imageData;\n  } else if (imageData) {\n    return new Texture2D(gl, {\n      parameters: DEFAULT_TEXTURE_PARAMETERS,\n      ...imageData,\n    });\n  }\n}\n","import GL from '@luma.gl/constants';\nimport {SimpleMeshLayer} from '@deck.gl/mesh-layers';\nimport {Model, Geometry, isWebGL2} from '@luma.gl/core';\nimport {project32, phongLighting, picking, log} from '@deck.gl/core';\nimport {ProgramManager} from '@luma.gl/engine';\n\nimport {shouldComposeModelMatrix} from './matrix';\nimport {loadImages} from '../images';\nimport fs from './raster-mesh-layer-fragment';\n\nfunction validateGeometryAttributes(attributes) {\n  log.assert(\n    attributes.positions || attributes.POSITION,\n    'RasterMeshLayer requires \"postions\" or \"POSITION\" attribute in mesh property.'\n  );\n}\n\n/*\n * Convert mesh data into geometry\n * @returns {Geometry} geometry\n */\nfunction getGeometry(data) {\n  if (data.attributes) {\n    validateGeometryAttributes(data.attributes);\n    if (data instanceof Geometry) {\n      return data;\n    } else {\n      return new Geometry(data);\n    }\n  } else if (data.positions || data.POSITION) {\n    validateGeometryAttributes(data);\n    return new Geometry({\n      attributes: data,\n    });\n  }\n  throw Error('Invalid mesh');\n}\n\nconst defaultProps = {\n  ...SimpleMeshLayer.defaultProps,\n  modules: {type: 'array', value: [], compare: true},\n  images: {type: 'object', value: {}, compare: true},\n  moduleProps: {type: 'object', value: {}, compare: true},\n};\n\nexport default class RasterMeshLayer extends SimpleMeshLayer {\n  initializeState() {\n    const {gl} = this.context;\n    const programManager = ProgramManager.getDefaultProgramManager(gl);\n\n    const fsStr1 = 'fs:DECKGL_MUTATE_COLOR(inout vec4 image, in vec2 coord)';\n    const fsStr2 = 'fs:DECKGL_CREATE_COLOR(inout vec4 image, in vec2 coord)';\n\n    // Only initialize shader hook functions _once globally_\n    // Since the program manager is shared across all layers, but many layers\n    // might be created, this solves the performance issue of always adding new\n    // hook functions. See #22\n    if (!programManager._hookFunctions.includes(fsStr1)) {\n      programManager.addShaderHook(fsStr1);\n    }\n    if (!programManager._hookFunctions.includes(fsStr2)) {\n      programManager.addShaderHook(fsStr2);\n    }\n\n    // images is a mapping from keys to Texture2D objects. The keys should match\n    // names of uniforms in shader modules\n    this.setState({images: {}});\n\n    super.initializeState();\n  }\n\n  getShaders() {\n    const transpileToGLSL100 = !isWebGL2(this.context.gl);\n    const {modules = []} = this.props;\n\n    // use object.assign to make sure we don't overwrite existing fields like `vs`, `modules`...\n    return Object.assign({}, super.getShaders(), {\n      fs,\n      transpileToGLSL100,\n      modules: [project32, phongLighting, picking, ...modules],\n    });\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n\n    if (\n      props.mesh !== oldProps.mesh ||\n      changeFlags.extensionsChanged ||\n      props.modules !== oldProps.modules\n    ) {\n      if (this.state.model) {\n        this.state.model.delete();\n      }\n      if (props.mesh) {\n        this.setState({model: this.getModel(props.mesh)});\n\n        const attributes = props.mesh.attributes || props.mesh;\n        this.setState({\n          hasNormals: Boolean(attributes.NORMAL || attributes.normals),\n        });\n      }\n      this.getAttributeManager().invalidateAll();\n    }\n\n    if (props && props.images) {\n      this.updateImages({props, oldProps});\n    }\n\n    if (this.state.model) {\n      this.state.model.setDrawMode(\n        this.props.wireframe ? GL.LINE_STRIP : GL.TRIANGLES\n      );\n    }\n  }\n\n  updateImages({props, oldProps}) {\n    const {images} = this.state;\n    const {gl} = this.context;\n\n    const newImages = loadImages({\n      gl,\n      images,\n      props,\n      oldProps,\n    });\n\n    if (newImages) {\n      this.setState({images: newImages});\n    }\n  }\n\n  draw({uniforms}) {\n    const {model, images} = this.state;\n    const {moduleProps} = this.props;\n\n    // Render the image\n    if (\n      !model ||\n      !images ||\n      Object.keys(images).length === 0 ||\n      !Object.values(images).every((item) => item)\n    ) {\n      return;\n    }\n\n    const {viewport} = this.context;\n    const {sizeScale, coordinateSystem, _instanced} = this.props;\n\n    model\n      .setUniforms(\n        Object.assign({}, uniforms, {\n          sizeScale,\n          composeModelMatrix:\n            !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),\n          flatShading: !this.state.hasNormals,\n        })\n      )\n      .updateModuleSettings({\n        ...moduleProps,\n        ...images,\n      })\n      .draw();\n  }\n\n  finalizeState() {\n    super.finalizeState();\n\n    if (this.state.images) {\n      for (const image of Object.values(this.state.images)) {\n        if (Array.isArray(image)) {\n          image.map((x) => x.delete());\n        } else {\n          image.delete();\n        }\n      }\n    }\n  }\n\n  getModel(mesh) {\n    const {gl} = this.context;\n\n    const model = new Model(\n      gl,\n      Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: getGeometry(mesh),\n        isInstanced: true,\n      })\n    );\n\n    return model;\n  }\n}\n\nRasterMeshLayer.layerName = 'RasterMeshLayer';\nRasterMeshLayer.defaultProps = defaultProps;\n","export default `#version 300 es\n#define SHADER_NAME raster-mesh-layer-fs\n\nprecision highp float;\n\nuniform bool hasTexture;\n\nuniform bool flatShading;\nuniform float opacity;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  geometry.uv = vTexCoord;\n  vec4 image;\n  DECKGL_CREATE_COLOR(image, vTexCoord);\n\n  DECKGL_MUTATE_COLOR(image, vTexCoord);\n\n  vec3 normal;\n  if (flatShading) {\n\n// NOTE(Tarek): This is necessary because\n// headless.gl reports the extension as\n// available but does not support it in\n// the shader.\n#ifdef DERIVATIVES_AVAILABLE\n    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n  } else {\n    normal = normals_commonspace;\n  }\n\n  vec3 lightColor = lighting_getLightColor(image.rgb, cameraPosition, position_commonspace.xyz, normal);\n  fragColor = vec4(lightColor, opacity);\n\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n","export const TERRAIN_IMAGE = `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png`;\nexport const MOSAIC_URL =\n  's3://kylebarron-landsat-test/mosaics/8113f57876010a63aadacef4eac6d010d10c9aafcf36a5ece064ea7f.json.gz';\n\nfunction colorStr(nBands) {\n  const colorBands = 'RGB'.slice(0, nBands);\n  let colorStr = `gamma ${colorBands} 3.5, sigmoidal ${colorBands} 15 0.35`;\n\n  if (nBands === 3) {\n    colorStr += ', saturation 1.7';\n  }\n  return colorStr;\n}\n\nexport function getLandsatUrl(options) {\n  const {bands, url, x, y, z} = options;\n  const bandsArray = Array.isArray(bands) ? bands : [bands];\n  const params = {\n    url,\n    bands: bandsArray.join(','),\n    color_ops: colorStr(bandsArray.length),\n  };\n  const searchParams = new URLSearchParams(params);\n  let baseUrl = `https://us-west-2-lambda.kylebarron.dev/landsat/tiles/${z}/${x}/${y}.jpg?`;\n  baseUrl += searchParams.toString();\n  return baseUrl;\n}\n\nexport function getTerrainUrl({x, y, z}) {\n  return TERRAIN_IMAGE.replace('{x}', x).replace('{y}', y).replace('{z}', z);\n}\n\nexport const ELEVATION_DECODER = {\n  rScaler: 256,\n  gScaler: 1,\n  bScaler: 1 / 256,\n  offset: -32768,\n};\n\n// Error suggestion from here\n// https://www.linkedin.com/pulse/fast-cesium-terrain-rendering-new-quantized-mesh-output-alvaro-huarte/\nexport function getMeshMaxError(z) {\n  return 77067.34 / (1 << z);\n}\n","import GL from '@luma.gl/constants';\nimport {COORDINATE_SYSTEM} from '@deck.gl/core';\nimport {load, registerLoaders} from '@loaders.gl/core';\nimport {TerrainLoader} from '@loaders.gl/terrain';\nimport {ImageLoader} from '@loaders.gl/images';\nimport {TileLayer} from '@deck.gl/geo-layers';\nimport {Matrix4} from 'math.gl';\nimport {\n  RasterMeshLayer,\n  combineBands,\n  pansharpenBrovey,\n  normalizedDifference,\n  colormap,\n} from '@kylebarron/deck.gl-raster';\n\nimport {\n  ELEVATION_DECODER,\n  getLandsatUrl,\n  getTerrainUrl,\n  getMeshMaxError,\n} from './util';\n\nregisterLoaders([ImageLoader]);\n\nconst DUMMY_DATA = [1];\n\n// NOTE: others should change this URL\n// Refer to `cogeo-mosaic` documentation for more information on mosaic backends\n// https://github.com/developmentseed/cogeo-mosaic\nconst MOSAIC_URL = 'dynamodb://us-west-2/landsat8-2019-spring';\n\nexport function TerrainTileLayer({minZoom = 7, maxZoom = 12} = {}) {\n  return new TileLayer({\n    id: 'terrain-tiles',\n    minZoom,\n    maxZoom,\n    tileSize: 256,\n    maxRequests: 12,\n    getTileData,\n    renderSubLayers,\n  });\n}\n\nasync function getTileData({x, y, z, landsatBands = [5, 4]}) {\n  const usePan =\n    z >= 12 &&\n    landsatBands[0] === 4 &&\n    landsatBands[1] === 3 &&\n    landsatBands[2] === 2;\n  const useColormap = true;\n  const colormapUrl =\n    'https://cdn.jsdelivr.net/gh/kylebarron/deck.gl-raster/assets/colormaps/spectral.png';\n  const modules = [combineBands, normalizedDifference];\n\n  // Load terrain\n  const terrainUrl = getTerrainUrl({x, y, z});\n  const bounds = [0, 1, 1, 0];\n  const terrain = loadTerrain({\n    terrainImage: terrainUrl,\n    bounds,\n    elevationDecoder: ELEVATION_DECODER,\n    meshMaxError: getMeshMaxError(z),\n  });\n\n  const bandsUrls = landsatBands.map((band) =>\n    getLandsatUrl({x, y, z, bands: band, url: MOSAIC_URL})\n  );\n  const imageBands = bandsUrls.map((url) => loadImage(url));\n\n  let imagePan;\n  if (usePan) {\n    const panUrl = getLandsatUrl({x, y, z, bands: 8, url: MOSAIC_URL});\n    imagePan = loadImage(panUrl);\n    modules.push(pansharpenBrovey);\n  }\n\n  // Load colormap\n  // Only load if landsatBandCombination is not RGB\n  let imageColormap;\n  if (useColormap) {\n    imageColormap = loadImage(colormapUrl);\n    modules.push(colormap);\n  }\n\n  // Await all images together\n  await Promise.all([imagePan, imageBands, imageColormap]);\n\n  const images = {\n    imageBands: await Promise.all(imageBands),\n    imageColormap: await imageColormap,\n    imagePan: await imagePan,\n  };\n\n  return {\n    images,\n    modules,\n    terrain: await terrain,\n  };\n}\n\nfunction renderSubLayers(props) {\n  const {data, tile} = props;\n\n  if (!data) {\n    return null;\n  }\n\n  const {images, modules, terrain} = data;\n\n  return [\n    new RasterMeshLayer(props, {\n      data: DUMMY_DATA,\n      mesh: terrain,\n      modules,\n      images,\n      getPolygonOffset: null,\n      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n      modelMatrix: getModelMatrix(tile),\n      getPosition: (d) => [0, 0, 0],\n      // Color to use if surfaceImage is unavailable\n      getColor: [255, 255, 255],\n    }),\n  ];\n}\n\n// From https://github.com/uber/deck.gl/blob/b1901b11cbdcb82b317e1579ff236d1ca1d03ea7/modules/geo-layers/src/mvt-tile-layer/mvt-tile-layer.js#L41-L52\nfunction getModelMatrix(tile) {\n  const WORLD_SIZE = 512;\n  const worldScale = Math.pow(2, tile.z);\n\n  const xScale = WORLD_SIZE / worldScale;\n  const yScale = -xScale;\n\n  const xOffset = (WORLD_SIZE * tile.x) / worldScale;\n  const yOffset = WORLD_SIZE * (1 - tile.y / worldScale);\n\n  return new Matrix4()\n    .translate([xOffset, yOffset, 0])\n    .scale([xScale, yScale, 1]);\n}\n\nfunction loadTerrain({\n  terrainImage,\n  bounds,\n  elevationDecoder,\n  meshMaxError,\n  workerUrl,\n}) {\n  if (!terrainImage) {\n    return null;\n  }\n  const options = {\n    terrain: {\n      bounds,\n      meshMaxError,\n      elevationDecoder,\n    },\n  };\n  if (workerUrl) {\n    options.terrain.workerUrl = workerUrl;\n  }\n  return load(terrainImage, TerrainLoader, options);\n}\n\nexport async function loadImage(url) {\n  const image = await load(url, ImageLoader);\n  return {\n    data: image,\n    format: image && image.height === 10 ? GL.RGB : GL.LUMINANCE,\n  };\n}\n","import React from 'react';\nimport DeckGL from '@deck.gl/react';\nimport {TerrainTileLayer} from './terrain-tile-layer';\n\nconst INITIAL_VIEW_STATE = {\n  latitude: 46.21,\n  longitude: -122.18,\n  zoom: 11.5,\n  bearing: 140,\n  pitch: 60,\n  // My landsat tile server doesn't support very low zooms\n  minZoom: 7,\n  maxPitch: 80,\n};\n\nexport default class App extends React.Component {\n  render() {\n    const layers = TerrainTileLayer({minZoom: 7, maxZoom: 12});\n\n    return (\n      <DeckGL\n        initialViewState={INITIAL_VIEW_STATE}\n        controller={true}\n        layers={layers}\n        glOptions={{\n          // Tell browser to use discrete GPU if available\n          powerPreference: 'high-performance',\n        }}\n      />\n    );\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: {'Service-Worker': 'script'},\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}